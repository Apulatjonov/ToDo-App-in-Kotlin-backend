package com.example.todo.services

import com.example.todo.constant.Constant
import com.example.todo.dtos.UserDto
import com.example.todo.entities.ChangePasswordToken
import com.example.todo.entities.ConfirmationToken
import com.example.todo.entities.User
import com.example.todo.exceptions.*
import com.example.todo.mappers.UserMapper
import com.example.todo.repositories.ChangePasswordTokenRepository
import com.example.todo.repositories.ConfirmationTokenRepository
import com.example.todo.repositories.UserRepository
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.regex.Pattern

@Service
class UserService : UserServiceInterface {

    @Autowired
    lateinit var userRepository: UserRepository

    @Autowired
    lateinit var confirmationTokenRepository: ConfirmationTokenRepository

    @Autowired
    lateinit var changePasswordRepository: ChangePasswordTokenRepository

    @Autowired
    lateinit var mailService: EmailService

    @Autowired
    lateinit var userMapper: UserMapper

    @Transactional
    override fun registerUser(dto: UserDto): UserDto {
        checkEmail(dto.email)

        val exists = userRepository.existsByEmail(dto.email)
        if (exists) {
            throw UserAlreadyExistException(Constant.EMAIL_ALREADY_EXISTS_ERROR_MESSAGE, User() as Any, "email")
        }
        val entity = userMapper.mapToEntity(dto)
        val savedUser = userRepository.save(entity)

        val token = ConfirmationToken(savedUser)
        confirmationTokenRepository.save(token)
        sendMail(savedUser.email!!)

        return userMapper.mapToDto(savedUser)
    }

    override fun sendMail(email: String): Boolean {
        val user = userRepository.findByEmail(email)
        if (user.isEmpty) {
            throw UserNotFoundException(Constant.USER_NOT_FOUND, User() as Any, "email")
        }

        var token = confirmationTokenRepository.findConfirmationTokenByUserId(user.get().id!!);

        var link = Constant.MAIN_URL + "/users/verifyAccount?token=" + token.get().token
        var body = StringBuilder()
                .append("<p>")
                .append("Welcome to ToDo App!").append("<br>")
                .append("Please click <a href=%s>here</a> to verify your e-mail").append("<br>").append("<br>")
                .append("Thank you for doing that,").append("<br>")
                .append("This is an autogenerated mail. Do not reply to this.")
                .append("</p>")
                .toString();
        body = String.format(body, link)

        mailService.sendMail(email, "ToDo App verification!", body)
        return true
    }

    @Transactional
    override fun confirmUserAccount(token: String): UserDto {
        var confirmationToken = confirmationTokenRepository.findByToken(token)
        if (confirmationToken.isEmpty) {
            throw NotFoundException(Constant.TOKEN_NOT_FOUND, ConfirmationToken() as Any, "token")
        }
        val user = confirmationToken.get().user
        if (user!!.verified) {
            throw UserAlreadyExistException(Constant.USER_ALREADY_VERIFIED, User() as Any, "confirmation token")
        } else {
            user.verified = true
            return userMapper.mapToDto(userRepository.save(user))
        }
    }

    override fun login(dto: UserDto): UserDto {
        val user = userRepository.findByEmail(dto.email)
        if (user.isEmpty) {
            throw UserNotFoundException(Constant.USER_NOT_FOUND, User() as Any, "Email");
        }
        if (!userMapper.checkPassword(dto.password, user.get().password)) {
            throw InvalidPasswordException(Constant.INVALID_PASSWORD, User() as Any, "Password")
        }
        val userDto = userMapper.mapToDto(user.get())
        userDto.tokenType = Constant.TOKEN_TYPE

        return userDto
    }

    override fun resetPassword(email: String): String {
        val user = userRepository.findByEmail(email)
        if (user.isEmpty) {
            throw UserNotFoundException(Constant.USER_NOT_FOUND, User() as Any, "Email")
        }
        var token: ChangePasswordToken? = null
        val tokens = changePasswordRepository.findAllByUserId(user.get().id!!)
        var tokenExists = true;
        if (tokens.get().size != 0){
            println("Tokens present")
            for (tok in tokens.get()){
                if (!tok.used){
                    token = tok
                    tokenExists = false
                    break
                }
            }
        }
        if(tokenExists){
            println("Tokens not present")
            token = ChangePasswordToken(user.get())
            changePasswordRepository.save(token)
        }
        var link = Constant.MAIN_URL + "/users/resetPassword?token=" + token?.token
        var body = java.lang.StringBuilder()
                .append("<p>")
                .append("Someone requested a password reset on your CloudGantt account. If you didn't make this request, please ignore this e-mail.")
                .append("If you did make this request, simply click button below to change your password").append("<br>")
                .append("<form><a href=%s>")
                .append("<button type=\"submit\"> Change password </button>")
                .append("</a></form>")
                .append("<br>").append("<br>")
                .append("This is an autogenerated mail. Do not reply to this.")
                .append("</p>")
                .toString()
        body = String.format(body, link)

        mailService.sendMail(email, "ToDo App Password reset!", body)
        return "Check your email!"
    }

    override fun changePassword(token: String, dto: UserDto): UserDto {
        val token = changePasswordRepository.findByToken(token)
        if (token.isEmpty){
            throw TokenNotFoundException(Constant.TOKEN_NOT_FOUND, ChangePasswordToken() as Any, "Token")
        }
        if (token.get().used){
            throw TokenAlreadyUsedException(Constant.TOKEN_ALREADY_USED, ChangePasswordToken(), "Token")
        }
        val user = userRepository.findByEmail(dto.email)
        if (user.isEmpty){
            throw UserNotFoundException(Constant.USER_NOT_FOUND, User(), "Email")
        }
        var newUser = user.get()
        newUser.password = userMapper.encodePassword(dto.password)
        val result = userRepository.save(newUser)
        token.get().used = true
        changePasswordRepository.save(token.get())
        return userMapper.mapToDto(result)
    }

    override fun updateUserById(id: Long, dto: UserDto): UserDto {
        val userEntity = userRepository.findById(id)
        if (userEntity.isEmpty){
            throw UserNotFoundException(Constant.USER_NOT_FOUND, User(), "Id")
        }
        var user = userEntity.get()
        if (!user.email.equals(dto.email)){
            sendMail(dto.email)
            user.verified = false
        }
        if (!userMapper.checkPassword(user.password, userMapper.encodePassword(dto.password))){
            user.password = userMapper.encodePassword(dto.password)
        }
        val entity = userRepository.save(user)
        return userMapper.mapToDto(entity)
    }

    private fun checkEmail(email: String) {
        if (!Pattern.matches(Constant.EMAIL_RFC_5322_REGEX, email)) {
            throw InvalidEmailException(Constant.INVALID_EMAIL, User() as Any, "Email")
        }
    }
}